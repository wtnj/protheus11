/*---------------------------------------------------------------------------+
!                             FICHA TÉCNICA DO PROGRAMA                      !
+----------------------------------------------------------------------------+
!   DADOS DO PROGRAMA                                                        !
+------------------+---------------------------------------------------------+
!Tipo              ! Rotina                                                  !
+------------------+---------------------------------------------------------+
!Módulo            ! Compras/PCP                                             !
+------------------+---------------------------------------------------------+
!Nome              ! PWHBM001                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! MRP - Ferramentas                                       !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 18/02/2010                                              !
+------------------+---------------------------------------------------------+
!   ATUALIZACÕES                                                             !
+-------------------------------------------+-----------+-----------+--------+
!   Descrição detalhada da atualização      !Nome do    ! Analista  !Data da !
!                                           !Solicitante! Respons.  !Atualiz.!
+-------------------------------------------+-----------+-----------+--------+
!                                           !           !           !        !
!                                           !           !           !        !
+-------------------------------------------+-----------+-----------+--------+
!                                           !           !           !        !
!                                           !           !           !        !
+-------------------------------------------+-----------+-----------+-------*/
#Include 'Protheus.ch'
#Include 'Rwmake.ch'
#Include 'dbTree.ch'

user Function pWhbm001()

Local cTitulo := "MRP - Ferramentas"
Local aDescri := {}
Local aBotao  := {}
Local lOk     := .F.
Private cPerg := "PWHBM001  "
Private cAl   := "TRBMRPFER"
Private oGetDados
Private mvpar01
Private mvpar02
Private mvpar03
Private mvpar04
Private aTree := {}
	/*
	aTree[1] := Tipo (P ou F)
	aTree[1] := Codigo do Tree
	aTree[1] := Codigo do Produto
	aTree[1] := Codigo da Ferramenta
	*/

CriaSx1(cPerg)
Pergunte(cPerg, .F.)

//--Tela para breve descrição da Rotina, e para botões Parametros, Ok e cancelar
AADD(aDescri,"Este programa processa o MRP - Ferramentas de acordo com a previsão de vendas")
AADD(aDescri,"em conjunto com a Ferramentas X Operações, gerando tela para consulta e confirmação")
AADD(aDescri,"para crição de solicitação de compras de ferramentas.")
AADD(aBotao,{5, .T., {|| Pergunte(cPerg, .T.)}})
AADD(aBotao,{1, .T., {|o| o:oWnd:End(), lOk := .T.}})
AADD(aBotao,{2, .T., {|o| o:oWnd:End()}})
FormBatch(cTitulo,aDescri,aBotao)
	
If lOk
    
	//--Verifica parametro de data
	If mv_par01 > mv_par02
		Aviso("Data","Parâmetros: Data inicial deve ser menor que data final.",{"Ok"},1)
	
	//--Verifica parametro de produto
	ElseIf mv_par03 > mv_par04
		Aviso("Produto","Parâmetro: Produto inicial deve ser menor que o produto final.",{"Ok"},1)

	//--Se tudo ok, chama funções
	Else

		//--Backup dos parametros
		//--caso alguma função chame um pergunte não dara problema aqui
		mvpar01 := mv_par01
		mvpar02 := mv_par02
		mvpar03 := mv_par03
		mvpar04 := mv_par04

		//--A primeira função é responsavel por fazer o relacionamento entre
		//--SC4 - previsao e ZDJ - Ferramentas
		Processa({||pWhbProc()})

		//--Se o processamento retornar registros
		//--Vetor aTree tera registros
		If (Len(aTree) > 0)

			//--A segunda função é responsavel por mostrar a tela de visualização
			Processa({||pWhbView()})

		Else

			//--Avisa ao usuario que não a dados
			Aviso("Sem registros","Não existem registros para serem apresentados, verifique os parâmetros.",{"OK"},1)

		Endif
	Endif
		
Endif

//--Fecha Alias Temporario
If Select(cAl) > 0
	dbSelectArea(cAl)
	dbCloseArea()
Endif

Return

/*-----------------+---------------------------------------------------------+
!Nome              ! pWhbProc                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! Processamento do MRP - Ferramentas                      !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 19/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pWhbProc()

Local aProd := {}
	/*
	aProd[1] := Saldo Atual
	aProd[2] := Entrada
	aProd[3] := Saida
	aProd[4] := Saldo Estoque
	aProd[5] := Necessidade
	*/
Local aFerr := {}
	/*
	aFerr[1] := Saldo Atual
	aFerr[2] := Necessidade
	aFerr[3] := Outras Necessidades
	aFerr[4] := Qtde Comprar
	aFerr[5] := Custo unitario
	aFerr[6] := Custo Total
	*/
Local cSc4 := "TMP_SC4"
Local cSd1 := "TMP_SD1"
Local cSd2 := "TMP_SD2"
Local cOut := "TMP_OUT"
Local nSaldo := 0

Local cProd := "P000000"
Local cFerr := "F000000"
Local cWhere := ""

//--Variaveis Montagem do arquivo Temporario
Local aCampos := {}
Local cNomeArq := CriaTrab(Nil,.F.)
Local cIndArq1 := CriaTrab(Nil,.F.)
Local cIndArq2 := CriaTrab(Nil,.F.)

//--Verifica se alias esta aberto
If Select(cAl) > 0
	dbSelectArea(cAl)
	dbCloseArea()
EndIf

//--Estrutura do arquivo temporario
aAdd(aCampos,{"DBTREE","C",07,0}) //-- Codigo do TREE
aAdd(aCampos,{"PRODUT","C",15,0}) //-- Codigo do produto
aAdd(aCampos,{"FERRAM","C",15,0}) //-- Codigo da Ferramenta
aAdd(aCampos,{"OPERAC","C",03,0}) //-- Codigo da Operação
aAdd(aCampos,{"CCUSTO","C",09,0}) //-- Codigo da Centro de Custo
aAdd(aCampos,{"SEQ"   ,"C",01,0}) //-- Sequencia que sera mostrado
aAdd(aCampos,{"TIPO"  ,"C",15,0}) //-- Tipo

//--FOR com as data para montagem do arquivo temporario
//--Com colunas data
For xD := mvpar01 to mvpar02
	aAdd(aCampos,{"C"+DtoS(xD),"N",15,2}) //--Data

Next

//--Cria o Arquivo temporario
dbCreate(cNomeArq,aCampos)
dbUseArea(.T.,,cNomeArq,cAl,.F.,.F.)
IndRegua(cAl,cIndArq1,"DBTREE+SEQ",,,"Criando indice um...")
IndRegua(cAl,cIndArq2,"FERRAM",,,"Criando indice dois...")

dbClearIndex()
dbSetIndex(cIndArq1+OrdBagExt())
dbSetIndex(cIndArq2+OrdBagExt())

//--Tabela de produto vs operação
dbSelectArea("ZDJ")
dbSetOrder(1) //Filial+Produto+Ferramenta
dbGoTop()

//--Posiciona no registro do parametro inicial
dbSeek(xFilial("ZDJ")+mvpar03,.t.)

//--Regua
ProcRegua(ZDJ->(RecCount()))

While !ZDJ->(Eof()) .And. ZDJ->ZDJ_PROD >= mvpar03 ; //--Maior ou igual ao parametro Produto De
                    .And. ZDJ->ZDJ_PROD <= mvpar04   //--Menor ou igual ao parametro Produto Para

	//--Incrementa regua
	IncProc("Produto: "+ZDJ->ZDJ_PROD)
	cWhere := ZDJ->ZDJ_PROD
	aProd := {}

	//--Abre os alias referentes ao produto do SDJ
	//--Necessidade
	//--Entradas
	//--Saidas
	abreProd(ZDJ->ZDJ_PROD,cSc4,cSd1,cSd2)

	//--Verifica se o produto possui necessidades
	//--Se a consulta do SC4 retornar Vazio, segnifica que não tem previsao de vendas
	If (cSc4)->(Eof())

		//--Enquanto não for fim de arquivo e for o mesmo produto
		While !ZDJ->(Eof()) .And. ZDJ->ZDJ_PROD == cWhere

			//--Vai pulando de linha
			ZDJ->(dbSkip())		

		Enddo

		//--Depois faz Loop
		Loop

	Endif
	
	//--A primeira linha consulta saldo em estoque atual do dia da consulta
	aAdd(aProd,{bSaldo(ZDJ->ZDJ_PROD),pBuscaValor(cSd1,mvpar01),pBuscaValor(cSd2,mvpar01),0,pBuscaValor(cSc4,mvpar01)})
	
	//--Calcula saldo do próximo dia
	//--Saldo inicial + ( Entradas - Saidas ) + Necessidade
	aProd[1,4] := aProd[1,1]+(aProd[1,2]-aProd[1,3])
	nSaldo := aProd[1,1]+(aProd[1,2]-aProd[1,3])+aProd[1,5]

	//--Agora do Saldo Inicial é composto pelo do dia anterior
	//--e inicial da data inicial + 1 até a data final
	For xD := (mvpar01+1) to mvpar02

		//--Monta Saldos do Dia
		aAdd(aProd,{nSaldo,pBuscaValor(cSd1,xD),pBuscaValor(cSd2,xD),0,pBuscaValor(cSc4,xD)})

		//--Calcula saldo do próximo dia
		//--Saldo inicial + ( Entradas - Saidas ) + Necessidade
		aProd[Len(aProd),4] := aProd[Len(aProd),1]+(aProd[Len(aProd),2]-aProd[Len(aProd),3])
		nSaldo := aProd[Len(aProd),1]+(aProd[Len(aProd),2]-aProd[Len(aProd),3])+aProd[Len(aProd),5]
		
	Next

	//--Soma1 ao codigo Atual
	cProd := Soma1(cProd)
	//--Gravação dos dados no arquivo temporario
	GravaTMP(aProd,"P",cProd,ZDJ->ZDJ_PROD,Space(TamSx3("B1_COD")[1]))

	//--Agora fara os calculos de ferramenta
	While !ZDJ->(Eof()) .And. ZDJ->ZDJ_PROD == cWhere

		aFerr := {}

		//--Pega custo medio do produto usando armazém padrão B1_LOCPAD
		nCusto := bCusto()
		consulNecess(cOut)

		//--A primeira linha consulta saldo em estoque atual do dia da consulta
		aAdd(aFerr,{bSaldo(ZDJ->ZDJ_FERRAM,.t.),bNecessidade(aProd,mvpar01),pBuscaValor(cOut,mvpar01),0,nCusto,0})

		//--Calcula saldo do próximo dia
		//--Saldo inicial - Necessidade
		nSaldo := aFerr[1,1]
		
		//--Se saldo for maior ou igual a necessidade total
		If (nSaldo >= aFerr[1,3])
			//--Subtrai do saldo
			nSaldo -= aFerr[1,3]
			//-- e zera qtde a comprar
			aFerr[1,4] := 0
		
		//--se o saldo for menor
		Else
			//--Subtrai da qtde a comprar
			aFerr[1,4] := aFerr[1,3]
			aFerr[1,4] -= nSaldo
			
			//--zera saldo
			nSaldo := 0
		Endif	

		//--Atualiza valor total
		aFerr[1,6] := (aFerr[1,4]*aFerr[1,5])

		//--Atualiza o campo outras necessidade
		//--Necessidade total - necessidade desta ferramentaxproduto
		aFerr[1,3] -= aFerr[1,2]

		//--Agora do Saldo Inicial é composto pelo do dia anterior
		//--e inicial da data inicial + 1 até a data final
		For xD := (mvpar01+1) to mvpar02
	
			//--Monta Saldos do Dia
			aAdd(aFerr,{nSaldo,bNecessidade(aProd,xD),pBuscaValor(cOut,xD),0,nCusto,0})

			//--Calcula saldo do próximo dia
			//--Saldo inicial - Necessidade
			//--Se saldo for maior oi igual
			If (nSaldo >= aFerr[Len(aFerr),3])
				//--Subtrai do saldo
				nSaldo -= aFerr[Len(aFerr),3]
				//-- e zera qtde a comprar
				aFerr[Len(aFerr),4] := 0
			
			//--se o saldo for menor
			Else
				//--Subtrai da qtde a comprar
				aFerr[Len(aFerr),4] := aFerr[Len(aFerr),3]
				aFerr[Len(aFerr),4] -= nSaldo
				//--zera saldo
				nSaldo := 0
			Endif

			//--Atualiza valor total
			aFerr[Len(aFerr),6] := aFerr[Len(aFerr),4]*aFerr[Len(aFerr),5]

			//--Atualiza o campo outras necessidade
			//--Necessidade total - necessidade desta ferramentaxproduto
			aFerr[Len(aFerr),3] -= aFerr[Len(aFerr),2]

		Next

		//--Soma1 ao codigo Atual
		cFerr := Soma1(cFerr)
		//--Gravação dos dados no arquivo temporario
		GravaTMP(aFerr,"F",cFerr,ZDJ->ZDJ_PROD,ZDJ->ZDJ_FERRAM)

		ZDJ->(dbSkip())

	Enddo

Enddo

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! consulNecess                                            !
+------------------+---------------------------------------------------------+
!Descrição         ! consulta necessidade total de uma ferramentas para todos!
!                  ! os produtos                                             !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 05/03/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function consulNecess(cOut)

//--Fecha Alias Temporario se estiver aberto
If Select(cOut) > 0
	dbSelectArea(cOut)
	dbCloseArea()
Endif

//--Consulta a necessidade total por dia do periodo
beginSql Alias cOut
	select 
	  xdj.data
	, sum(xdj.quant) quant
	from (
		select
		  SC4.C4_PRODUTO produto
		, SC4.C4_DATA data
		, ceiling(sum(SC4.C4_QUANT)/avg(ZDJ.ZDJ_VUSET)*avg(ZDJ.ZDJ_FMONT)*avg((ZDJ.ZDJ_INDREF+100)/100)*avg((ZDJ.ZDJ_INQUE+100)/100)) quant
		from
			%table:ZDJ% ZDJ
		inner join
				%table:SC4% SC4
			on  SC4.C4_FILIAL = %xFilial:SC4%
			and SC4.C4_PRODUTO = ZDJ.ZDJ_PROD
			and SC4.C4_DATA >= %Exp:mvpar01%
			and SC4.C4_DATA <= %Exp:mvpar02%
			and SC4.D_E_L_E_T_ = ' '
		where
			ZDJ.ZDJ_FILIAL = %xFilial:ZDJ%
		and ZDJ.ZDJ_FERRAM = %Exp:ZDJ->ZDJ_FERRAM%
		and ZDJ.D_E_L_E_T_ = ' '
		group by 
		  SC4.C4_PRODUTO 
		, SC4.C4_DATA
		, ZDJ.R_E_C_N_O_
	) xdj
	group by xdj.data 
endSql

return


/*-----------------+---------------------------------------------------------+
!Nome              ! aliasProd                                               !
+------------------+---------------------------------------------------------+
!Descrição         ! abre os alias SC4, SD1 e SD2                            !
!                  ! Para não fazer uma consulta por dia de cada produto,    !
!                  ! faço do periodo para cada produto                       !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 19/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function abreProd(cProd,cSc4,cSd1,cSd2)

//--Fecha Alias Temporario se estiver aberto
If Select(cSc4) > 0
	dbSelectArea(cSc4)
	dbCloseArea()
Endif

//--Consulta as Previsões de venda
beginSql Alias cSc4
	select 
		C4_DATA       as data
	,   sum(C4_QUANT) as quant
	from 
		%table:SC4%
	where 
		C4_FILIAL  = %xFilial:SC4%
	and C4_PRODUTO = %Exp:cProd%
	and C4_DATA   >= %Exp:DtoS(mvpar01)%
	and C4_DATA   <= %Exp:DtoS(mvpar02)%
	and C4_MRP     = ' '
	and D_E_L_E_T_ = ' '
	group by
		C4_DATA	
endSql

//--Fecha Alias Temporario se estiver aberto
If Select(cSd1) > 0
	dbSelectArea(cSd1)
	dbCloseArea()
Endif

//--Consulta as Previsões de venda
beginSql Alias cSd1
	select 
	    SF1.F1_DTDIGIT    as data
	,   sum(SD1.D1_QUANT) as quant
	from
	    %table:SF1% SF1
	inner join
	        %table:SD1% SD1
	    on  SD1.D1_FILIAL   = %xFilial:SD1%
	    and SD1.D1_COD      = %Exp:cProd%
	    and SD1.D1_DOC      = SF1.F1_DOC
	    and SD1.D1_SERIE    = SF1.F1_SERIE
	    and SD1.D1_FORNECE  = SF1.F1_FORNECE
	    and SD1.D1_LOJA     = SF1.F1_LOJA
	    and SD1.D1_FORMUL   = SF1.F1_FORMUL
	    and SD1.D1_ORIGLAN != 'LF'
	    and SD1.D1_REMITO   = '         '
	    and SD1.D_E_L_E_T_  = ' '
	inner join
	        %table:SF4% SF4
	    on  SF4.F4_FILIAL  = %xFilial:SF4%
	    and SF4.F4_CODIGO  = SD1.D1_TES
	    and SF4.F4_ESTOQUE = 'S'
	    and SD1.D_E_L_E_T_ = ' '
	where
	    SF1.F1_FILIAL  = %xFilial:SF1%
	and SF1.F1_DTDIGIT >= %Exp:DtoS(mvpar01)%
	and SF1.F1_DTDIGIT <= %Exp:DtoS(mvpar02)%
	and SF1.D_E_L_E_T_ = ' '
	group by SF1.F1_DTDIGIT
	order by SF1.F1_DTDIGIT
endSql

//--Fecha Alias Temporario se estiver aberto
If Select(cSd2) > 0
	dbSelectArea(cSd2)
	dbCloseArea()
Endif

//--Consulta as Previsões de venda
beginSql Alias cSd2
	select 
	    SF2.F2_DTDIGIT    as data
	,   sum(SD2.D2_QUANT) as quant
	from
	    %table:SF2% SF2
	inner join
	        %table:SD2% SD2
	    on  SD2.D2_FILIAL   = %xFilial:SD2%
	    and SD2.D2_COD      = %Exp:cProd%
	    and SD2.D2_DOC      = SF2.F2_DOC
	    and SD2.D2_SERIE    = SF2.F2_SERIE
	    and SD2.D2_CLIENTE  = SF2.F2_CLIENTE
	    and SD2.D2_LOJA     = SF2.F2_LOJA
	    and SD2.D2_FORMUL   = SF2.F2_FORMUL
	    and SD2.D2_ORIGLAN != 'LF'
	    and SD2.D2_TPDCENV != '1A'
	    and SD2.D2_REMITO   = '         '
	    and SD2.D_E_L_E_T_  = ' '
	inner join
	        %table:SF4% SF4
	    on  SF4.F4_FILIAL  = %xFilial:SF4%
	    and SF4.F4_CODIGO  = SD2.D2_TES
	    and SF4.F4_ESTOQUE = 'S'
	    and SD2.D_E_L_E_T_ = ' '
	where
	    SF2.F2_FILIAL  = %xFilial:SF4%
	and SF2.F2_DTDIGIT >= %Exp:DtoS(mvpar01)%
	and SF2.F2_DTDIGIT <= %Exp:DtoS(mvpar02)%
	and SF2.D_E_L_E_T_ = ' '
	group by SF2.F2_DTDIGIT
	order by SF2.F2_DTDIGIT
endSql

Return

/*-----------------+---------------------------------------------------------+
!Nome              ! bSaldo                                                  !
+------------------+---------------------------------------------------------+
!Descrição         ! Calcula saldo do produto para todos os armazem para o   !
!                  ! dia expecificado                                        !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 20/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function bSaldo(cProd,lY) 

Local nRet := 0

default lY := .F.

dbSelectArea("SB1")
dbSetOrder(1)
dbSeek(xFilial()+cProd)

//--Seleciona tabela de Saldos
dbSelectArea("SB2")
SB2->(dbSetOrder(1))
SB2->(dbSeek(xFilial()+cProd))

While !Eof() .And. SB2->B2_FILIAL+SB2->B2_COD == xFilial("SB1")+cProd
	
	//--Pega somente a primeira possição do vetor de retorno
	//nRet += CalcEst(cProd,SB2->B2_LOCAL,dData)[1]
	nRet += SB2->B2_QATU
	
	//--Proxima linha
	SB2->(dbSkip())

Enddo

//--Ferramenta reafiada 
//--Se o quarto digito do do produto for 1
//--e se B1_TIPO diferente de "PA"
//--Podera ter uma ferramenta reafiada
If subStr(cProd,4,1) == "1" .And. lY

	//--Verifica se Existe o produto
	If SB1->(dbSeek(xFilial()+subStr(cProd,1,3)+"5"+subStr(cProd,5,11)))

		SB2->(dbSeek(xFilial()+subStr(cProd,1,3)+"5"+subStr(cProd,5,11)))
		
		While !Eof() .And. SB2->B2_FILIAL+SB2->B2_COD == xFilial("SB1")+subStr(cProd,1,3)+"5"+subStr(cProd,5,11)
			
			//--Pega somente a primeira possição do vetor de retorno
			nRet += SB2->B2_QATU
			
			//--Proxima linha
			SB2->(dbSkip())
		
		Enddo

	Endif

Endif

Return nRet

/*-----------------+---------------------------------------------------------+
!Nome              ! pBuscaValor                                             !
+------------------+---------------------------------------------------------+
!Descrição         ! Pega saldo de entradas ou saida ou provisao do dia      !
!                  ! especificado, de acordo com o alias passado             !              
+------------------+---------------------------------------------------------+
!Data de Criação   ! 20/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pBuscaValor(xAl,dData) 

Local nRet := 0

//--Verifica se arquivo não esta em EOF
//--e se a data é igual ao do parametro
//--nunca sera menor
If !(xAl)->(Eof()) .And. DtoS(dData) == (xAl)->data
	
	//--Pega quantidade
	nRet := (xAl)->quant

	//--Proxima linha
	(xAl)->(dbSkip())

Endif

Return nRet


/*-----------------+---------------------------------------------------------+
!Nome              ! bNecessidade                                            !
+------------------+---------------------------------------------------------+
!Descrição         ! Calcula a necessidade do produto de acordo com calculo  !
!                  ! com previsao de vendas e indices da tabela ZDJ          !              
+------------------+---------------------------------------------------------+
!Data de Criação   ! 22/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function bNecessidade(aProd,dData) 

Local nRet := 0

//--Programação Total * Vida Util do Set Montado * Ferramentas por Montagem * Indice de Refugo * Indice de quebra
nRet := aProd[(dData-mvpar01)+1,5] / ZDJ->ZDJ_VUSET * ZDJ->ZDJ_FMONT * ((ZDJ->ZDJ_INDREF+100)/100) * ((ZDJ->ZDJ_INQUE+100)/100)

//--Arredonda valor para cima ex: 1.96 = 2 , 1.01 = 2
nRet := Ceiling(nRet)

Return nRet


/*-----------------+---------------------------------------------------------+
!Nome              ! bCusto                                                  !
+------------------+---------------------------------------------------------+
!Descrição         ! Pega o Custo médio do produto produto de acordo com arma!
!                  ! zém padrão do produto                                   !              
+------------------+---------------------------------------------------------+
!Data de Criação   ! 22/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function bCusto()

Local nRet := 0

//--Seleciona o produto para pegar o armazém padrão
dbSelectArea("SB1")
dbSetOrder(1)
dbSeek(xFilial("SB1")+ZDJ->ZDJ_FERRAM)

dbSelectArea("SB2")
dbSetOrder(1)

//--Pode não haver um registro para este armazém
If dbSeek(xFilial("SB2")+SB1->B1_COD+SB1->B1_LOCPAD)
	nRet := SB2->B2_CM1
Endif

Return nRet


/*-----------------+---------------------------------------------------------+
!Nome              ! GravaTMP                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! Gravação no Arquivo temporario                          !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 22/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function GravaTMP(aDados,cTipo,cCodigo,cProd,cFerr)

Local xD

//--Montagem do Vetor para montagem do dbTree
aAdd(aTree,{cTipo,cCodigo,cProd,cFerr})

//--Percorre as linhas do vetor bidimencial
For nX := 1 To Len(aDados[1])

	//--Recebe valor do parametro de data inicial
	xD := mvpar01

	//--Gravação
	RecLock(cAl,.T.)

	(cAl)->DBTREE := cCodigo
	(cAl)->PRODUT := cProd
	(cAl)->FERRAM := cFerr
	(cAl)->SEQ    := Str(nX,1)
	(cAl)->TIPO   := cTipo
	
	//--Se o Tipo igual a F
	If cTipo == "F"
		//--Grava Centro de Custo e Operação
		(cAl)->OPERAC := ZDJ->ZDJ_OP
		(cAl)->CCUSTO := ZDJ->ZDJ_CC
	Endif

	//--Percore as colunas
	For nY := 1 to Len(aDados)

		//--Grava nas datas
		(cAl)->&("C"+DtoS(xD)) := aDados[nY,nX]
		//--Adiciona 1 a data atual
		xD++

	Next
	
	MsUnLock()

Next

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! pWhbView                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! Mostra tela de visualização e confirmação               !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 18/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pWhbView()

Local oTree
Local oDlg
Local oPanel
Local oFont
Local aSize   := MsAdvSize()
Local nTop    := aSize[7]+23
Local nLeft   := 0+5
Local nBottom := aSize[6]-60
Local nRight  := aSize[5]-10
Local aButtons := {}

Private oQuant
Private oCusto

Define Font oFont  Name "Arial" SIZE 0,-9
Define Font oFont2 Name "Arial" SIZE 0,-12 Bold
Define MsDialog oDlg Title "MRP - Ferramentas" OF oMainWnd Pixel From nTop,nLeft To nBottom,nRight

//--Teste para ver se consulta fical mais Rapida
ultimaCompra("")

//--Cria um painel
oPanel := TPanel():New(17,160,'',oDlg,oDlg:oFont,.T.,.T.,,,(nRight-nLeft)/2-160,((nBottom)/2)-2,.T.,.T. )

//--Coloca o dbTree dentro do painel
oTree := dbTree():New(17, 2,((nBottom)/2)+16,159,oDlg,,,.T.)
oTree:bChange := {|| mudaClique(@oTree,{0,0,((nBottom-nTop)/2)+17,(nRight-nLeft)/2-160},@oPanel) }
oTree:SetFont(oFont)
oTree:lShowHint := .F.

//--Monta o dbTree
MontaTree(@oTree)
mudaClique(@oTree,{0,0,((nBottom-nTop)/2)+17,(nRight-nLeft)/2-160},@oPanel)

//--Legenda
@ ((nBottom)/2)+18,05 Bitmap oBmp Resname "PMSEDT2" Of oDlg Size 8,8 Adjust NoBorder When .F. Pixel
@ ((nBottom)/2)+18,43 Bitmap oBmp Resname "PMSEDT3" Of oDlg Size 8,8 Adjust NoBorder When .F. Pixel
TSay():New(((nBottom)/2)+19,15,{||"Produto"   },oDlg,,oFont2,,,,.T.,CLR_BLUE,,,,,,,,)
TSay():New(((nBottom)/2)+19,53,{||"Ferramenta"},oDlg,,oFont2,,,,.T.,CLR_BLUE,,,,,,,,)

Activate MsDialog oDlg On Init EnchoiceBar(oDlg,{||oDlg:End(),Processa({||pWhbComp()})},{||oDlg:End()},,aButtons)

Return

/*-----------------+---------------------------------------------------------+
!Nome              ! mudaClique                                              !
+------------------+---------------------------------------------------------+
!Descrição         ! Função responsavel por atualizar o scroll com os informa!
!                  ! ções do item do Tree clicado                            !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 18/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function mudaClique(oTree,aPos,oPanel)

Local cProd := ""
Local cCor := CLR_BLUE
Local aProd := {"Saldo Estoque",;
				"Entrada",;
				"Saída",;
				"Saldo Estoque",;
				"Necessidade"}
Local aFerr := {"Saldo Estoque",;
				"Necessidade",;
				"Outras Necessidades",;
				"Qtde Comprar",;
				"Custo Unitário",;
				"Custo Total"}
Local aDados := {}
Local aRet := {}

Define Font oFont  Name "Arial" Size 0,-15 Bold
Define Font oFont2 Name "Arial" Size 0,-11 Bold

//--Oculta painel
oPanel:Hide()
oPanel:FreeChildren()

//--Se for produto
If subStr(oTree:GetCargo(),1,1) == "P"

	//--Monta Scroll
	oScroll := TScrollBox():New(oPanel,aPos[1],aPos[2],aPos[3],aPos[4])
	TSay():New(10,05,{||"PREVISÃO DE VENDAS"},oScroll,,oFont,,,,.T.,cCor,,,,,,,,)

    //--MontaGetDados
    //--1.Vetor com a posição do GetDados
    //--Objeto oScroll
    //--Objeto oTree
    //--Vetor com a descrição das linhas (coluna tipo)
	MontaGetDados({30,2,95,aPos[4]-5},@oScroll,@oTree,aProd,".F.")
    
//--Se for ferramenta	
Else

	//--Busca dados da ultima compra
	cProd := subStr(oTree:GetPrompt(),1,15)
	aDados := ultimaCompra(cProd)

	//--Monta scroll 
	oScroll := TScrollBox():New(oPanel,aPos[1],aPos[2],aPos[3],aPos[4])
	TSay():New(10,05,{||"DADOS DE COMPRA"},oScroll,,oFont,,,,.T.,cCor,,,,,,,,)

	TSay():New(25,05,{||"Ultimo Fornecedor:"}                 ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(25,60,{||allTrim(aDados[1])}                   ,oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(34,05,{||"Ultimo Preço:"}                      ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(34,60,{||TransForm(aDados[2],"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(43,05,{||"Quantidade:"}                        ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(43,60,{||TransForm(aDados[3],"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(51,05,{||"Data:"}                              ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(51,60,{||DtoC(StoD(aDados[4]))}                ,oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(60,05,{||"Valor Total:"}                       ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(60,60,{||TransForm(aDados[5],"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(69,05,{||"Saldo produto novo: "+cProd}         ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
	TSay():New(69,60,{||transForm(bSaldo(cProd),"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	
	cProd := subStr(cProd,1,3)+"5"+subStr(cProd,5,11)
	dbSelectArea("SB1")
	dbSetOrder(1)

	If dbSeek(xFilial("SB1")+cProd) .And. subStr(oTree:GetPrompt(),4,1) == "1"
		TSay():New(78,05,{||"Saldo produto reafiado: "+cProd}  ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
		TSay():New(78,60,{||transForm(bSaldo(cProd),"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	Else
		TSay():New(78,05,{||"Saldo produto reafiado:"}        ,oScroll,,oFont2,,   ,,.T.,cCor,,   , ,,,,,)
		TSay():New(78,60,{||"Não Encontrado"}                 ,oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	
	Endif

	//--MontaGetDados
    //--1.Vetor com a posição do GetDados
    //--Objeto oScroll
    //--Objeto oTree
    //--Vetor com a descrição das linhas (coluna tipo)
	aRet := MontaGetDados({90,2,162,aPos[4]-5},@oScroll,@oTree,aFerr,".F.")
   
	TSay():New(165,05,{||"TOTAL GERAL"}                      ,oScroll,,oFont,,,,.T.,cCor,,,,,,,,)
	TSay():New(180,05,{||"Qtde Total Comprar:"}              ,oScroll,,oFont2,,,,.T.,cCor,,,,,,,,)
	oQuant := TSay():New(180,60,{||TransForm(aRet[4],"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)
	TSay():New(189,05,{||"Quantidade:"}                      ,oScroll,,oFont2,,,,.T.,cCor,,,,,,,,)
	oCusto := TSay():New(189,60,{||TransForm(aRet[6],"999,999,999.99")},oScroll,,oFont2,,.t.,,.T.,cCor,,190,8,,,,,)

Endif

//--Mostra Painel
oPanel:Show()

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! MontaTree                                               !
+------------------+---------------------------------------------------------+
!Descrição         ! Popula/monta os dados no dbTree                         !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 18/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function MontaTree(oTree)

oTree:Hide()
oTree:Reset()
oTree:BeginUpdate()

oTree:TreeSeek("")

//--Percorre o Vetor para montar o tree
For nK := 1 to Len(aTree)

	//--Se for Tipo = P adiciona no nivel 1
	If aTree[nK,1] == "P"

		//--Adiciona item no nivel 1 do tree
		oTree:AddItem(aTree[nK,3]+" / "+Posicione("SB1",1,xFilial("SB1")+aTree[nK,3],"B1_DESC"),aTree[nK,2],"PMSEDT2",,,,1)
		//--Da um seek no nivel recem adicionado
		oTree:TreeSeek(aTree[nK,2])
	
	//--Se for tipo = F adiciona no nivel 2
	Else
		
		//--Adiciona item no segundo nivel, embaixo do ultimo primeiro
		oTree:AddItem(aTree[nK,4]+" / "+Posicione("SB1",1,xFilial("SB1")+aTree[nK,4],"B1_DESC"),aTree[nK,2],"PMSEDT3",,,,2)	

    Endif                     

Next

oTree:Refresh()
oTree:EndUpdate()

//--Volta para primeiro registro do tree
oTree:TreeSeek(aTree[1,2])

oTree:Show()

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! MontaGetDados                                           !
+------------------+---------------------------------------------------------+
!Descrição         ! Função responsavel pela montagem da getDados para       !
!                  ! produtos e ferramentas                                  !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 19/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function MontaGetDados(aPos,oScroll,oTree,aLinhas,cWhen)

Local aAlter       	:= {}
Local nOpc         	:= 0
Local cLinhaOk     	:= "AllwaysTrue"
Local cTudoOk      	:= "AllwaysTrue"
Local cIniCpos     	:= ""
Local nFreeze      	:= 0
Local nMax         	:= 6
Local cCampoOk     	:= "AllwaysTrue"
Local cSuperApagar 	:= ""
Local cApagaOk     	:= "AllwaysTrue"
Local aHead        	:= {}
Local aCol         	:= {}
Local aDados := {}
Local aRet := {0,0,0,0,0,0}

//--Campo Fixo
aAdd(aHead,{'Tipo',"TIPO","",20,0,'AllWaysTrue()','.t.','C','','V',,,'.F.'})
aAdd(aDados,"Tipo")

//--Campos Data, variavel
For xD := mvpar01 to mvpar02
	aAdd(aHead,{DtoC(xD),"C"+DtoS(xD),'@E 999,999,999.99',12,2,"u_vFerr(M->C"+DtoS(xD)+",'C"+DtoS(xD)+"','"+oTree:GetCargo()+"')",'.t.','N','','V',,,cWhen})
	aAdd(aAlter,"C"+DtoS(xD))
Next

dbSelectArea(cAl)
(cAl)->(dbGoTop())
(cAl)->(dbSetOrder(1))

For nX := 1 To Len(aLinhas)

	//--Inicia com vetor auxiliar limpo
	aAux := {}

	//--Localiza o registro no arquivo temporario
	(cAl)->(dbSeek(oTree:GetCargo()+Str(nX,1)))
	
	//--Primeira coluna é do tipo
	aAdd(aAux,aLinhas[nX])

	//--Colunas com datas recebe valor
	For xD := mvpar01 To mvpar02
		aAdd(aAux,(cAl)->&("C"+DtoS(xD)))
		aRet[nX] += (cAl)->&("C"+DtoS(xD))
	Next

	//--Flag de registro deletado/não deletado
	aAdd(aAux,.F.)

	//--Adiciona a Linha no aCols
	aAdd(aCol,aClone(aAux))
Next

oGetDados := MsNewGetDados():New(aPos[1],aPos[2],aPos[3],aPos[4],nOpc,cLinhaOk,cTudoOk,cIniCpos,;
aAlter,nFreeze,nMax,cCampoOk,cSuperApagar,cApagaOk,oScroll,aHead,aCol)

oGetDados:Refresh()

Return(aRet)


/*-----------------+---------------------------------------------------------+
!Nome              ! vFerr                                                   !
+------------------+---------------------------------------------------------+
!Descrição         ! Atualização do GetDados quando alterado campo Necessidade
+------------------+---------------------------------------------------------+
!Data de Criação   ! 24/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
user Function vFerr(nValor,cCampo,cCodTree)

Local aDados := {}
Local aAux := {}
Local nSaldo := {}
Local nQuant := 0
Local nCusto := 0

//--Se o usuario clicar e não alterar o valor não tem pq processar a atualização
//--Só atualiza se for diferente
If oGetDados:aCols[oGetDados:nAt,aScan(oGetDados:aHeader,{|x|allTrim(x[2])==cCampo})] != nValor

	//--Como é validação o campo ainda não recebeu o valor digitado
	oGetDados:aCols[oGetDados:nAt,aScan(oGetDados:aHeader,{|x|allTrim(x[2])==cCampo})] := nValor
	
	//--Agora inverto colunas e linhas (mais facil de trabalhar)
	//--Percorre as linhas do vetor bidimencial
	//--Começa da Coluna 2 (ignora TIPO) e termina no ultima coisa -1 (flag deletado)
	For nX := 2 To Len(oGetDados:aCols[1])-1
	
		//--Limpa vetor
		aAux := {}
	
		//--Percore as colunas
		For nY := 1 to Len(oGetDados:aCols)
	
			//--Adiciona ao vetor auxiliar as colunas de uma linha
			aAdd(aAux,oGetDados:aCols[nY,nX])
	
		Next
	
		//--Adiciona o vetor principal a linhas inteira
		aAdd(aDados,aClone(aAux))
	
	Next


	cMsg := ""
	For x := 1 to Len(aDados)
		cMsg += alltrim(str(aDados[x,1]))+"|"
		cMsg += alltrim(str(aDados[x,2]))+"|"
		cMsg += alltrim(str(aDados[x,3]))+"|"
		cMsg += alltrim(str(aDados[x,4]))+"|"
		cMsg += alltrim(str(aDados[x,5]))+chr(13)+chr(10)
	Next


	//--Pego o saldo Inicial
	nSaldo := aDados[1,1]
	
	//--Reprocessamento dos dados da Ferramento conforme alteração da Necessidade
	For nS := 1 to Len(aDados)

		aDados[nS,1] := nSaldo

		//--Calcula saldo do próximo dia
		//--Saldo inicial - Necessidade
		//--Se saldo for maior oi igual
		If (nSaldo >= aDados[nS,2])

			//--Subtrai do saldo
			nSaldo -= aDados[nS,2]
			
			//--e zera qtde a comprar
			aDados[nS,3] := 0
		
		//--se o saldo for menor
		Else

			//--Subtrai da qtde a comprar
			aDados[nS,3] := aDados[nS,2]
			aDados[nS,3] -= nSaldo

			//--zera saldo
			nSaldo := 0

		Endif

		//--Atualiza valor total
		aDados[nS,5] := aDados[nS,3]*aDados[nS,4]

		nQuant += aDados[nS,3]
		nCusto += aDados[nS,5]

	Next

	cMsg := ""
	For x := 1 to Len(aDados)
		cMsg += alltrim(str(aDados[x,1]))+"|"
		cMsg += alltrim(str(aDados[x,2]))+"|"
		cMsg += alltrim(str(aDados[x,3]))+"|"
		cMsg += alltrim(str(aDados[x,4]))+"|"
		cMsg += alltrim(str(aDados[x,5]))+chr(13)+chr(10)
	Next


	//--Depois de Re-Processado atualizado o GetDados e o Arquivo temporario
	For nX := 1 To Len(aDados[1])

		//--Recebe valor do parametro de data inicial
		xD := mvpar01

		//--Localiza o registros no arquivo temporario
		dbSelectArea(cAl)
		(cAl)->(dbSeek(cCodTree+Str(nX,1)))

		//--Alteração
		RecLock(cAl,.F.)
		
		//--Percore as colunas
		For nY := 1 to Len(aDados)

			//--Grava nas datas
			(cAl)->&("C"+DtoS(xD)) := aDados[nY,nX]

			//--Atualiza do GetDados
			oGetDados:aCols[nX,nY+1] := aDados[nY,nX]

			//--Adiciona 1 a data atual
			xD++
	
		Next
	
		MsUnLock()
	
	Next

	oQuant:cCaption := TransForm(nQuant,"999,999,999.99")
	oCusto:cCaption := TransForm(nCusto,"999,999,999.99")
	
	//--Atualiza o GetDados
	oGetDados:Refresh()

Endif

Return(.T.)


/*-----------------+---------------------------------------------------------+
!Nome              ! ultimaCompra                                            !
+------------------+---------------------------------------------------------+
!Descrição         ! Consuta dados da ultima compra                          !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 23/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function ultimaCompra(cProd)

Local cAz := "TMPULTCOM"
Local aRet := {}

beginSql Alias cAz
	select
	    TOP 1
	    SD1.D1_DTDIGIT as data
	,   SA2.A2_NOME    as nome
	,   SD1.D1_FORNECE as cod
	,   SD1.D1_LOJA    as loja
	,   SD1.D1_QUANT   as quant
	,   SD1.D1_VUNIT   as vunit
	,   SD1.D1_TOTAL   as total
	from
	    %table:SD1% SD1
	inner join
	        %table:SF4% SF4
	    on  SF4.F4_FILIAL  = %xFilial:SF4%
	    and SF4.F4_CODIGO  = SD1.D1_TES
	    and SF4.F4_ESTOQUE = 'S'
	    and SD1.D_E_L_E_T_ = ' '
	inner join
	        %table:SA2% SA2
	    on  SA2.A2_FILIAL = %xFilial:SA2%
	    and SA2.A2_COD    = SD1.D1_FORNECE
	    and SA2.A2_LOJA   = SD1.D1_LOJA
	    and SA2.D_E_L_E_T_ = ' '
	where
	    SD1.D1_FILIAL   = %xFilial:SD1%
	and SD1.D1_COD      = %Exp:cProd%
	and SD1.D1_ORIGLAN != 'LF'
	and SD1.D1_REMITO   = '         '
	and SD1.D_E_L_E_T_  = ' '
	order by SD1.D1_DTDIGIT DESC , D1_NUMSEQ DESC
endSql

If !(cAz)->(Eof())

	aAdd(aRet,(cAz)->cod+"/"+(cAz)->loja+" - "+(cAz)->nome) //--Codigo/Loja - Nome
	aAdd(aRet,(cAz)->vunit) //--Ultimo valo unitario
	aAdd(aRet,(cAz)->quant) //--quantidade
	aAdd(aRet,(cAz)->data)  //--Data
	aAdd(aRet,(cAz)->total) //--total

Else

	aAdd(aRet,"Não encontrado")
	aAdd(aRet,0)
	aAdd(aRet,0)
	aAdd(aRet,"")
	aAdd(aRet,0)

Endif

(cAz)->(dbCloseArea())

Return(aRet)


/*-----------------+---------------------------------------------------------+
!Nome              ! pWhbComp                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! Inclusão das solicitações de compra                     !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 24/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pWhbComp()

Local lAglut := (Aviso("Aglutina","Deseja aglutinar SCs da mesma ferramentas?",{"Sim","Não"},2)==1)

If lAglut

	//--Rotina para gerar SC's aglutinadas
	pWhbAglut()

Else

	//--Rotina para gerar SC's separadas
	pWhbNoAgt()

Endif

Return



/*-----------------+---------------------------------------------------------+
!Nome              ! pWhbAglut                                               !
+------------------+---------------------------------------------------------+
!Descrição         ! Inclusão das solicitações de compra Aglutinadas         !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 24/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pWhbAglut()

Local cFerr := ""
Local nQuant := 0
Local aM110Cab := {}
Local aM110Itens := {}
Local cNumero := ""
Local cFiltro := '(cAl)->FERRAM != Space(TamSx3("B1_COD")[1]) .And. (cAl)->SEQ == "4"'
Local cCusto := ""
Local lErro := .F.
Local cPadCst := subStr(superGetMv("MV_MRPCST",.f.,"ALMOXARI "),1,tamSx3("C1_CC")[1])

dbSelectArea(cAl)
(cAl)->(dbSetOrder(2)) //Ferramenta+Seq
MsgRun("Preparando para geração de SCs aglutinadas. Aguarde...","Aguarde...",{||(cAl)->(DbSetFilter(&("{||"+cFiltro+"}"), cFiltro))})

//--Regua
ProcRegua(mvpar02-mvpar01+1)

For xD := mvpar01 to mvpar02

	IncProc("Gerando dia "+DtoC(xD)+" ("+DtoC(mvpar01)+" até "+DtoC(mvpar02)+")...")

	//--Volta para primeiro registro
	(cAl)->(dbGoTop())

	//--Primeira Coisa a ser feita é aglutinar os valores por ferramenta
	While !(cAl)->(Eof())
	
		cFerr := (cAl)->FERRAM
		nQuant := 0
		cCusto := ""
		
		//--Aglutina registros com mesma ferramenta
		While !(cAl)->(Eof()) .and. (cAl)->FERRAM == cFerr

			//--Soma saldos
			nQuant := (cAl)->&("C"+DtoS(xD))
	        cCusto += allTrim((cAl)->CCUSTO)
	
			(cAl)->(dbSkip())

			//--Adiciona barra se não for o ultimo
			If !(cAl)->(Eof()) .and. (cAl)->FERRAM == cFerr
				cCusto += "/"
			Endif

		Enddo
        
		//--Só inclui a Solicitação se Qtde maior Zero
		If (nQuant > 0)

			//--Pega próximo numero da SC
			cNumero := NextNumero("SC1",1,"C1_NUM",.T.)

			dbSelectArea("SC1")
			dbSetOrder(1)
			
			dbSelectArea("SB1")
			dbSetOrder(1)
			
			dbSelectArea("SB2")
			dbSetOrder(1)

			//--Posiciona no produto
			SB1->(dbSeek(xFilial("SB1")+cFerr))
			SB2->(dbSeek(xFilial("SB2")+cFerr+SB1->B1_LOCPAD))

			//--Adequa o tamanho do conteudo da observação
			cCusto := subStr(cCusto,1,tamSx3("C1_OBS")[1])
	
			//--Itens
			//--Muito cuidade ao mexer na estrutura do vetor abaixo.
			//--A partit dele seja gerado  log das SCs, então, se precisar
			//--adicionar campos, coloque no final, depois do campo C1_TOTAL		
			aAdd(aM110Itens,{{"C1_ITEM"    ,strZero(Len(aM110Itens)+1,tamSx3("C1_ITEM")[1]),Nil},;
							 {"C1_PRODUTO" ,SB1->B1_COD                    ,Nil},;
							 {"C1_UM"      ,SB1->B1_UM                     ,Nil},;
							 {"C1_QUANT"   ,nQuant                         ,Nil},;
							 {"C1_OBS"     ,cCusto                         ,Nil},;
							 {"C1_CC"      ,cPadCst                        ,Nil},;
							 {"C1_DATPRF"  ,xD-SB1->B1_LT                  ,Nil},;
							 {"C1_CCU"     ,cPadCst                        ,Nil},;
			                 {"C1_LOCAL"   ,SB1->B1_LOCPAD                 ,Nil},;
							 {"C1_VUNIT"   ,SB2->B2_CM1                    ,Nil},;
							 {"C1_TOTAL"   ,nQuant*SB2->B2_CM1             ,Nil}})

		Endif

	Enddo

Next

//--Verifica se ha itens a serem gravados
If Len(aM110Itens) > 0

	//--Controle de transação
	begin Transaction

	//--Pega próximo numero da SC
	cNumero := NextNumero("SC1",1,"C1_NUM",.T.)

	//--Cabeçalho
	aM110Cab := {}
	aAdd(aM110Cab,{"C1_NUM"    ,cNumero  ,Nil})
	aAdd(aM110Cab,{"C1_EMISSAO",dDataBase,Nil})
	aAdd(aM110Cab,{"C1_SOLICIT",cUserName})

	lMsErroAuto := .f.

	//-- Executa ExecAuto para gravação da solicitação de compras
	msExecAuto({|x,y| Mata110(x,y)},aM110Cab,aM110Itens)

	//--Erro
	If lMsErroAuto
		
		//--Cria o diretório se não existir
		MontaDir("Erro MRP\")
		//--Grava o erro no diretório
		MostraErro("\Erro MRP\","["+dtoS(dDataBase)+"]["+strTran(Time(),":",".")+"]["+allTrim(cFerr)+"].err")

		Aviso("SCs não geradas","Não foi possivel fazer a gravação das SCs, verifique o log.",{"Ok"},2)

		DisarmTransaction()
	
	Else
	
		//--Monta update para flegar as provisões de vendas
		//--Caso for reprocessar, não ira encontrar nada
		cUpdate := " update "
		cUpdate +=      retSqlName("SC4")
		cUpdate += " set "
		cUpdate += " 	C4_MRP = 'P' "
		cUpdate += " where "
		cUpdate += " 	 C4_FILIAL   = '"+xFilial("SC4")+"' "
		cUpdate += " and C4_PRODUTO >= '"+mvpar03+"' "
		cUpdate += " and C4_PRODUTO <= '"+mvpar04+"' "
		cUpdate += " and C4_DATA    >= '"+DtoS(mvpar01)+"' "
		cUpdate += " and C4_DATA    <= '"+DtoS(mvpar02)+"' "
		cUpdate += " and D_E_L_E_T_  = ' ' "
		
		//--Grava o log das SCs
		gravaLog(aM110Itens)

		//--Executa o comando
		tcSqlExec(cUpdate)
	
		Aviso("SCs geradas","As SCs foram geradas com sucesso",{"Ok"},2)

	Endif

	//--Controle de transação
	end Transaction

Endif

//--Limpa o filtro
(cAl)->(dbClearFilter())

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! pWhbNoAgt                                               !
+------------------+---------------------------------------------------------+
!Descrição         ! Inclusão das solicitações de compra nao Aglutinadas     !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 24/02/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function pWhbNoAgt()

Local cFerr := ""
Local nQuant := 0
Local aM110Cab := {}
Local aM110Itens := {}
Local cNumero := ""
Local cFiltro := '(cAl)->FERRAM != Space(TamSx3("B1_COD")[1]) .And. (cAl)->SEQ $ "1#2"'
Local cCusto := ""
Local lErro := .F.
Local aSldAnt := {}
	/*
	aSldAnt[1] := Codigo do produto
	aSldAnt[2] := Saldo do dia anterior
	*/
Local aProds := {}
	/*
	aProds[1] := Codigo do produto
	aProds[2] := Codigo do CC
	aProds[3] := Saldo inicial
	aProds[4] := Necessidade
	aProds[5] := Comprar
	aProds[6] := Saldo Final
	*/
Local cPadCst := subStr(superGetMv("MV_MRPCST",.f.,"ALMOXARI "),1,tamSx3("C1_CC")[1])

dbSelectArea(cAl)
(cAl)->(dbSetOrder(2)) //Ferramenta+Seq
MsgRun("Preparando para geração de SCs Separadas. Aguarde...","Aguarde...",{||(cAl)->(DbSetFilter(&("{||"+cFiltro+"}"), cFiltro))})

//--Regua
ProcRegua(mvpar02-mvpar01+1)

For xD := mvpar01 to mvpar02

	IncProc("Gerando dia "+DtoC(xD)+" ("+DtoC(mvpar01)+" até "+DtoC(mvpar02)+")...")

	//--Volta para primeiro registro
	(cAl)->(dbGoTop())

	//--Primeira Coisa a ser feita é aglutinar os valores por ferramenta
	While !(cAl)->(Eof())
	
		cFerr := (cAl)->FERRAM
		aProds := {}
				
		//--Aglutina registros com mesma ferramenta
		While !(cAl)->(Eof()) .and. (cAl)->FERRAM == cFerr .And. (cAl)->SEQ == "1"

			//--Estamos na linha de saldo

			//--Se vetor vazio, carega primeira linha com saldo inicial
			If aScan(aSldAnt,{|x| x[1]=(cAl)->FERRAM}) == 0
	
				aAdd(aProds,{(cAl)->FERRAM,(cAl)->CCUSTO,(cAl)->&("C"+DtoS(xD)),0,0,0})

			//--se não pula linha sempre, porque é a linha de saldos
    		Else
				aAdd(aProds,{(cAl)->FERRAM,(cAl)->CCUSTO,aSldAnt[aScan(aSldAnt,{|x| x[1]=(cAl)->FERRAM}),2],0,0,0})
    			
    		Endif
            
			//--Proximo registro
			(cAl)->(dbSkip())

			//--Agora estamos na linha da necessidade

			//--Linha do vetor atual
			nL := Len(aProds)
			
			//--Necessidade do dia
			aProds[nL,4] := (cAl)->&("C"+DtoS(xD))
			
			//--Valor a comprar
			aProds[nL,5] := If(aProds[nL,4]>aProds[nL,3],aProds[nL,4]-aProds[nL,3],0)
			
			//--Saldo final
			aProds[nL,6] := If(aProds[nL,4]>=aProds[nL,3],0,aProds[nL,3]-aProds[nL,4])


			//--Verifica se já existe no vetor de saldos
			If aScan(aSldAnt,{|x| x[1]=(cAl)->FERRAM}) != 0
				
				//--Se já. muda o saldo
				aSldAnt[aScan(aSldAnt,{|x| x[1]=(cAl)->FERRAM}),2] := aProds[nL,6]

			Else
				
				//--Se não adiciona um novo
				aAdd(aSldAnt,{(cAl)->FERRAM,aProds[nL,6]})
			
			Endif

			(cAl)->(dbSkip())

		Enddo
        
		For nX := 1 To Len(aProds)

			//--Só inclui a Solicitação se Qtde maior Zero
			If (aProds[nX,5] > 0)

				dbSelectArea("SC1")
				dbSetOrder(1)
				
				dbSelectArea("SB1")
				dbSetOrder(1)
				
				dbSelectArea("SB2")
				dbSetOrder(1)

				//--Posiciona no produto
				SB1->(dbSeek(xFilial("SB1")+aProds[nX,1]))
				SB2->(dbSeek(xFilial("SB2")+SB1->B1_COD+SB1->B1_LOCPAD))
	
				//--Adequa o tamanho do conteudo da observação
				cCusto := subStr(aProds[nX,2],1,tamSx3("C1_OBS")[1])
		
		        //--Itens
				//--Muito cuidade ao mexer na estrutura do vetor abaixo.
				//--A partit dele seja gerado  log das SCs, então, se precisar
				//--adicionar campos, coloque no final, depois do campo C1_TOTAL		
				aAdd(aM110Itens,{{"C1_ITEM"   ,strZero(Len(aM110Itens)+1,tamSx3("C1_ITEM")[1]),Nil},;
								 {"C1_PRODUTO",SB1->B1_COD                        ,Nil},;
								 {"C1_UM"     ,SB1->B1_UM                         ,Nil},;
								 {"C1_QUANT"  ,aProds[nX,4]                       ,Nil},;
								 {"C1_OBS"    ,cCusto                             ,Nil},;
								 {"C1_CC"     ,cPadCst                            ,Nil},;
								 {"C1_DATPRF" ,xD-SB1->B1_LT                      ,Nil},;
								 {"C1_CCU"    ,subStr(cCusto,1,tamSx3("C1_CC")[1]),Nil},;
				                 {"C1_LOCAL"  ,SB1->B1_LOCPAD                     ,Nil},;
								 {"C1_VUNIT"  ,SB2->B2_CM1                        ,Nil},;
								 {"C1_TOTAL"  ,aProds[nX,4]*SB2->B2_CM1           ,Nil}})
		
			Endif

		Next

	Enddo

Next

//--Verifica se ha itens a serem gravados
If Len(aM110Itens) > 0

	//--Controle de transação
	begin Transaction

	//--Pega próximo numero da SC
	cNumero := NextNumero("SC1",1,"C1_NUM",.T.)

	//--Cabeçalho
	aM110Cab := {}
	aAdd(aM110Cab,{"C1_NUM"    ,cNumero  ,Nil})
	aAdd(aM110Cab,{"C1_EMISSAO",dDataBase,Nil})
	aAdd(aM110Cab,{"C1_SOLICIT",cUserName})


	lMsErroAuto := .f.

	//-- Executa ExecAuto para gravação da solicitação de compras
	msExecAuto({|x,y| Mata110(x,y)},aM110Cab,aM110Itens)

	//--Erro
	If lMsErroAuto
		
		//--Cria o diretório se não existir
		MontaDir("Erro MRP\")
		//--Grava o erro no diretório
		MostraErro("\Erro MRP\","["+dtoS(dDataBase)+"]["+strTran(Time(),":",".")+"]["+allTrim(cFerr)+"].err")

		Aviso("SCs não geradas","Não foi possivel fazer a gravação das SCs, verifique o log.",{"Ok"},2)

		DisarmTransaction()
	
	Else
	
		//--Monta update para flegar as provisões de vendas
		//--Caso for reprocessar, não ira encontrar nada
		cUpdate := " update "
		cUpdate +=      retSqlName("SC4")
		cUpdate += " set "
		cUpdate += " 	C4_MRP = 'P' "
		cUpdate += " where "
		cUpdate += " 	 C4_FILIAL   = '"+xFilial("SC4")+"' "
		cUpdate += " and C4_PRODUTO >= '"+mvpar03+"' "
		cUpdate += " and C4_PRODUTO <= '"+mvpar04+"' "
		cUpdate += " and C4_DATA    >= '"+DtoS(mvpar01)+"' "
		cUpdate += " and C4_DATA    <= '"+DtoS(mvpar02)+"' "
		cUpdate += " and D_E_L_E_T_  = ' ' "
		
		//--Executa o comando
		tcSqlExec(cUpdate)
	
		Aviso("SCs geradas","As SCs foram geradas com sucesso",{"Ok"},2)

	Endif

	//--Controle de transação
	end Transaction

Endif

//--Limpa o filtro
(cAl)->(dbClearFilter())

Return


/*-----------------+---------------------------------------------------------+
!Nome              ! gravaLog                                                !
+------------------+---------------------------------------------------------+
!Descrição         ! Grava no log, espelho da solicitação de compra          !
+------------------+---------------------------------------------------------+
!Data de Criação   ! 08/03/2010                                              !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
static Function gravaLog(aItens)

dbSelectArea("ZDM")

For nX := 1 to Len(aItens)

	recLock("ZDM",.t.)
	ZDM->ZDM_FILIAL := xFilial("ZDM")
	ZDM->ZDM_SOLIC  := cSc
	ZDM->ZDM_USER   := cUserName
	ZDM->ZDM_DATA   := dDataBase
	ZDM->ZDM_HORA   := SubStr(Time(),1,5)
	ZDM->ZDM_ITEM   := aItens[nX,01,2] //--Item
	ZDM->ZDM_PRODUT := aItens[nX,02,2] //--Codigo do Produto
	ZDM->ZDM_UM     := aItens[nX,03,2] //--Unidade
	ZDM->ZDM_QUANT  := aItens[nX,04,2] //--Quantidade
	ZDM->ZDM_OBS    := aItens[nX,05,2] //--Observação
	ZDM->ZDM_CC     := aItens[nX,06,2] //--Centro de Custo
	ZDM->ZDM_DATPRF := aItens[nX,07,2] //--Data de Necessidade
	ZDM->ZDM_CCU    := aItens[nX,08,2] //--Centro de Custo Usado
	ZDM->ZDM_LOCAL  := aItens[nX,09,2] //--Armazem padrao
	ZDM->ZDM_VUNIT  := aItens[nX,10,2] //--Valor Unitario
	ZDM->ZDM_TOTAL  := aItens[nX,11,2] //--Valor Total
	msUnLock()

Next

Return

/*-----------------+---------------------------------------------------------+
!Nome              ! CriaSx1                                                 !
+------------------+---------------------------------------------------------+
!Descrição         ! Cria perguntas                                          !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
Static Function CriaSx1()
PutSx1(cPerg,"01","Da Data?"      ,"Da Data?"      ,"Da data?"      ,"mv_ch1","D",08,0,0,"G","",""   ,"","","mv_par01","","","","","","","","","","","","","","","","",{"Da data"      ,"","",""},{"Da data"      ,"","",""},{"Da data"      ,"","",""},"")
PutSx1(cPerg,"02","Até a Data?"   ,"Até a Data?"   ,"Até a Data?"   ,"mv_ch2","D",08,0,0,"G","",""   ,"","","mv_par02","","","","","","","","","","","","","","","","",{"Até a data"   ,"","",""},{"Até a data"   ,"","",""},{"Até a data"   ,"","",""},"")
PutSx1(cPerg,"03","Do Produto?"   ,"Do Produto?"   ,"Do Produto?"   ,"mv_ch3","C",15,0,0,"G","","SB1","","","mv_par03","","","","","","","","","","","","","","","","",{"Do produto"   ,"","",""},{"Do produto"   ,"","",""},{"Do produto"   ,"","",""},"")
PutSx1(cPerg,"04","Até o Produto?","Até o Produto?","Até o Produto?","mv_ch4","C",15,0,0,"G","","SB1","","","mv_par04","","","","","","","","","","","","","","","","",{"Até o produto","","",""},{"Até o produto","","",""},{"Até o produto","","",""},"")
Return


/*-----------------+---------------------------------------------------------+
!Nome              ! Ceiling                                                 !
+------------------+---------------------------------------------------------+
!Descrição         ! Arredonda valor sempre pra cima                         !
+------------------+---------------------------------------------------------+
!Autor             ! Rafael Ricardo Vieceli                                  !
+------------------+--------------------------------------------------------*/
user Function Ceiling(nValor)

If Int(nValor) != nValor
	nValor := Int(nValor)+1
Endif

Return(nValor)